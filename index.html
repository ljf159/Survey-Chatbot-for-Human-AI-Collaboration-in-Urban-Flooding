<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Survey Chatbot</title>
    <style>
        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
        }

        body {
            background-color: #f9f9f9;
            min-height: 100vh;
            min-height: -webkit-fill-available; /* For iOS Safari */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            padding-bottom: calc(20px + var(--safe-area-inset-bottom));
        }

        /* Fix for mobile Safari */
        html {
            height: -webkit-fill-available;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 90vh; /* Default height */
            height: calc(90vh - var(--safe-area-inset-bottom)); /* Adjust for safe area */
            max-height: -webkit-fill-available;
        }

        .chat-header {
            padding: 15px 20px;
            background-color: #4a6fa5;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-icon {
            cursor: pointer;
            font-size: 1.4rem;
        }

        .chat-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            margin-bottom: 15px;
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 18px;
            line-height: 1.5;
            animation: fadeIn 0.3s ease;
            word-wrap: break-word;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user-message {
            background-color: #e3f2fd;
            margin-left: auto;
            border-bottom-right-radius: 5px;
        }

        .bot-message {
            background-color: #f1f1f1;
            margin-right: auto;
            border-bottom-left-radius: 5px;
        }

        /* Add this to your existing CSS */
        .bot-message {
            white-space: pre-wrap; /* This preserves line breaks */
            line-height: 1.5; /* Increases line spacing */
            max-width: 90%; /* Ensures messages don't stretch too wide */
            padding: 12px 12px; /* More padding for better spacing */
        }

        .bot-message p {
            margin-bottom: 2px; /* Adds space between paragraphs */
        }

        .thinking {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .dot {
            height: 8px;
            width: 8px;
            margin-right: 5px;
            background-color: #bbb;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 1s infinite;
        }

        .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(1); opacity: 0.5; }
        }

        .chat-input {
            display: flex;
            padding: 15px;
            background-color: #f1f1f1;
            border-top: 1px solid #ddd;
            gap: 10px;
            align-items: flex-start;
            min-height: fit-content;
        }

        .input-field {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 20px;
            outline: none;
            font-size: 1rem;
            resize: none;
            min-height: 44px;
            max-height: 120px;
            height: auto;
            overflow-y: auto;
            line-height: 1.5;
            font-family: inherit;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: height 0.1s ease;
            box-sizing: border-box;
            -webkit-appearance: none; /* Remove iOS default styling */
            appearance: none;
            -webkit-text-size-adjust: 100%; /* Prevent iOS font scaling */
        }

        .voice-btn, .send-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: #4a6fa5;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .voice-btn:hover, .send-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100vh;
            background-color: white;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }

        .settings-panel.open {
            right: 0;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-settings {
            cursor: pointer;
            font-size: 1.4rem;
        }

        .settings-content textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .settings-content button {
            padding: 8px 15px;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        /* Speech recognition status */
        .speech-status {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .speech-status.active {
            opacity: 1;
        }

        /* Speech recognition volume visualizer */
        .volume-meter {
            height: 5px;
            background-color: #ddd;
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
            display: none;
        }

        .volume-meter-bar {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.1s ease;
        }

        /* Language selection */
        .language-selector {
            margin: 15px 0;
        }

        .language-selector select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .container {
                max-width: 700px;
            }
        }

        @media (max-width: 992px) {
            .container {
                max-width: 600px;
            }
            
            .message {
                max-width: 90%;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                max-width: 100%;
                height: 95vh;
            }
            
            .chat-header {
                padding: 12px 15px;
                font-size: 1.1rem;
            }
            
            .chat-body {
                padding: 15px;
            }
            
            .message {
                max-width: 95%;
                padding: 10px 14px;
            }
            
            .chat-input {
                padding: 12px;
            }
            
            .input-field {
                padding: 10px 14px;
                font-size: 0.95rem;
            }
            
            .voice-btn, .send-btn {
                width: 40px;
                height: 40px;
            }
        }

        @media (max-width: 576px) {
            body {
                padding: 0;
            }
            
            .container {
                height: 100vh;
                height: calc(100vh - var(--safe-area-inset-bottom));
                max-height: -webkit-fill-available;
                border-radius: 0;
            }
            
            .chat-header {
                padding: 10px 12px;
                padding-top: max(10px, env(safe-area-inset-top));
                font-size: 1rem;
                position: sticky;
                top: 0;
                z-index: 10;
            }
            
            .chat-body {
                padding: 12px;
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .chat-input {
                padding: 10px;
                padding-bottom: max(10px, env(safe-area-inset-bottom));
                position: sticky;
                bottom: 0;
                background-color: #f1f1f1;
                z-index: 10;
            }
            
            .input-field {
                padding: 8px 12px;
                font-size: 16px; /* Prevent iOS zoom on focus */
                max-height: 100px;
            }
            
            .voice-btn, .send-btn {
                width: 36px;
                height: 36px;
                min-width: 36px; /* Prevent shrinking */
                min-height: 36px;
            }
            
            /* Ensure the speech status doesn't get hidden */
            .speech-status {
                bottom: calc(80px + var(--safe-area-inset-bottom));
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            .container {
                height: -webkit-fill-available;
            }
            
            .chat-body {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .chat-input {
                position: sticky;
                bottom: 0;
                margin-bottom: env(safe-area-inset-bottom);
            }
            
            .input-field {
                font-size: 16px; /* Prevent zoom on focus */
                line-height: 1.5;
                padding-top: 12px;
                padding-bottom: 12px;
                min-height: 44px;
                max-height: 120px;
            }
        }

        /* Dark Mode Support */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1a1a1a;
            }
            
            .container {
                background-color: #2d2d2d;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            
            .chat-header {
                background-color: #3d5a7c;
            }
            
            .message {
                color: #e0e0e0;
            }
            
            .user-message {
                background-color: #3d5a7c;
            }
            
            .bot-message {
                background-color: #3a3a3a;
            }
            
            .chat-input {
                background-color: #2d2d2d;
                border-top-color: #3a3a3a;
            }
            
            .input-field {
                background-color: #3a3a3a;
                color: #e0e0e0;
            }
            
            .settings-panel {
                background-color: #2d2d2d;
            }
        }

        /* High Contrast Mode Support */
        @media (forced-colors: active) {
            .container {
                border: 2px solid CanvasText;
            }
            
            .message {
                border: 1px solid CanvasText;
            }
            
            .input-field {
                border: 1px solid CanvasText;
            }
            
            .voice-btn, .send-btn {
                border: 1px solid CanvasText;
            }
        }

        /* Reduced Motion */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: none;
                padding: 0;
            }
            
            .container {
                box-shadow: none;
                height: auto;
                max-height: none;
            }
            
            .chat-input, .voice-btn, .send-btn, .settings-icon {
                display: none;
            }
            
            .chat-body {
                overflow: visible;
            }
            
            .message {
                break-inside: avoid;
                page-break-inside: avoid;
            }
        }

        /* Add these styles before the existing styles */
        .consent-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #fff;
            z-index: 2000;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .consent-content {
            max-width: 800px;
            margin: 0 auto;
            flex: 1;
        }

        .consent-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #4a6fa5;
        }

        .consent-section {
            margin-bottom: 20px;
        }

        .consent-section h3 {
            color: #4a6fa5;
            margin-bottom: 10px;
        }

        .consent-section p {
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .consent-options {
            margin: 20px 0;
        }

        .consent-option {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .consent-option input[type="radio"] {
            margin-right: 10px;
        }

        .consent-option label {
            cursor: pointer;
        }

        .consent-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            padding: 20px 0;
        }

        .consent-button {
            padding: 10px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .consent-button.agree {
            background-color: #4a6fa5;
            color: white;
        }

        .consent-button.disagree {
            background-color: #f1f1f1;
            color: #666;
        }

        .consent-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .consent-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Hide chat interface initially */
        .container {
            display: none;
        }

        /* Dark mode support for consent page */
        @media (prefers-color-scheme: dark) {
            .consent-page {
                background-color: #1a1a1a;
                color: #e0e0e0;
            }

            .consent-title, .consent-section h3 {
                color: #6a8fa5;
            }

            .consent-button.disagree {
                background-color: #3a3a3a;
                color: #e0e0e0;
            }
        }
    </style>
</head>
<body>
    <!-- Add consent page before the container -->
    <div class="consent-page" id="consentPage">
        <div class="consent-content">
            <h1 class="consent-title">Online Consent</h1>
            
            <div class="consent-section">
                <p>This survey is part of a research study conducted by Dr. Jinfeng Lou at Carnegie Mellon University and is funded by Carnegie Bosch Institute.</p>
            </div>

            <div class="consent-section">
                <h3>Summary</h3>
                <p>This study examines how professionals in urban flooding management interact with artificial intelligence (AI) tools and how human-AI collaboration can improve flood response and mitigation efforts. The study is designed to gather insights from professionals in transportation, emergency response, urban planning, AI development, and other related fields.</p>
            </div>

            <div class="consent-section">
                <h3>Purpose</h3>
                <p>The purpose of this research is to explore how human-AI collaboration can enhance decision-making, preparedness, and response to urban flooding. Understanding these interactions will help improve AI technologies and policies that support flood management.</p>
            </div>

            <div class="consent-section">
                <h3>Procedures</h3>
                <p>Participation in this study involves completing a 10-minute online survey facilitated by an AI-powered chatbot. The survey consists of multiple-choice and open-ended questions about your experience, perspectives on AI tools, and opinions on human-AI collaboration in flood management.</p>
            </div>

            <div class="consent-section">
                <h3>Participant Requirements</h3>
                <ul>
                    <li>Participation is limited to individuals 18 years or older.</li>
                    <li>Participants must be professionals involved in urban flooding-related fields, such as transportation departments, AI technology providers, urban planners, emergency services, sewer and drainage workers, frontline operators, meteorologists, or other relevant stakeholders.</li>
                </ul>
            </div>

            <div class="consent-section">
                <h3>Risks</h3>
                <p>The risks and discomfort associated with participation in this study are no greater than those ordinarily encountered in daily life or during other online activities. Your responses will be confidential, and no personally identifiable information will be shared.</p>
            </div>

            <div class="consent-section">
                <h3>Benefits</h3>
                <p>There may be no personal benefit from your participation in the study but the knowledge received will contribute to advancements in AI-assisted flood management, benefiting urban infrastructure and emergency response planning.</p>
            </div>

            <div class="consent-section">
                <h3>Compensation & Costs</h3>
                <p>There is no compensation for participation in this study. There will be no cost to you if you participate in this study.</p>
            </div>

            <div class="consent-section">
                <h3>Future Use of Information</h3>
                <p>Your anonymous responses may be used in future research studies on human-AI collaboration and flood management. De-identified data may also be shared with other researchers for academic purposes. All identifiable information will be removed.</p>
            </div>

            <div class="consent-section">
                <h3>Confidentiality</h3>
                <p>The data captured for the research does not include any personally identifiable information about you. Your IP address will not be captured. Research data will be securely stored and retained for a minimum of three years as per regulations. If a sponsor or regulatory authority requests access to the study data, only de-identified information will be shared.</p>
            </div>

            <div class="consent-section">
                <h3>Right to Ask Questions & Contact Information</h3>
                <p>If you have any questions about this study, you should feel free to ask them by contacting the Principal Investigator now at Dr. Jinfeng Lou, Department of Civil and Environmental Engineering, Pittsburgh, Pennsylvania, 15213, 412-320-6522, jinfengl@andrew.cmu.edu.</p>
                <p>If you have questions pertaining to your rights as a research participant; or to report concerns to this study, you should contact the Office of Research integrity and Compliance at Carnegie Mellon University. Email: irb-review@andrew.cmu.edu. Phone: 412-268-1901 or 412-268-5460.</p>
            </div>

            <div class="consent-section">
                <h3>Voluntary Participation</h3>
                <p>Your participation in this research is voluntary. You may discontinue participation at any time during the research activity. You may print a copy of this consent form for your records.</p>
            </div>

            <div class="consent-options">
                <div class="consent-option">
                    <input type="radio" id="age18" name="age18" value="yes">
                    <label for="age18">I am 18 or older.</label>
                </div>
                <div class="consent-option">
                    <input type="radio" id="understand" name="understand" value="yes">
                    <label for="understand">I have read and understand the information above.</label>
                </div>
                <div class="consent-option">
                    <input type="radio" id="participate" name="participate" value="yes">
                    <label for="participate">I want to participate in this research and continue with the survey.</label>
                </div>
            </div>

            <div class="consent-buttons">
                <button class="consent-button agree" id="agreeButton" disabled>I Agree</button>
                <button class="consent-button disagree" id="disagreeButton">I Do Not Agree</button>
            </div>
        </div>
    </div>

    <!-- Existing container div -->
    <div class="container">
        <div class="chat-header">
            <span>Survey Chatbot</span>
            <span class="settings-icon" onclick="toggleSettings()">⚙️</span>
        </div>
        <div class="chat-body" id="chatBody">
            <!-- Messages will be displayed here -->
        </div>
        <div class="chat-input">
            <textarea class="input-field" id="inputField" placeholder="Type your response here..." rows="1"></textarea>
            <button class="voice-btn" id="voiceBtn" title="Click to speak">🎤</button>
            <button class="send-btn" id="sendBtn" title="Send message">➤</button>
        </div>
        
        <!-- Speech recognition status -->
        <div class="speech-status" id="speechStatus">Listening...</div>
    </div>

    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <h3>Configure Survey</h3>
            <span class="close-settings" onclick="toggleSettings()">×</span>
        </div>
        <div class="settings-content">
            <h4>System Prompt (Survey Questions)</h4>
            <textarea id="systemPrompt" placeholder="Enter your survey questions and instructions here...">You are a friendly chatbot conducting a 10-minute survey on "Human-AI Collaboration in Urban Flooding." Target participants: transportation dept., AI tech providers (flooding-related), urban planners, emergency depts., sewer/drainage workers, frontline operators, and others (e.g., meteorologists, community leaders). Survey covers Demographics, Technology Assessment, Human-AI Collaboration Methods, Workforce Preparation, Ethical/Governance/Societal Issues, Economic Impact, and Policy Implications.            
                ### Instructions:
                1. Ask one question at a time, conversational and brief. For open-ended questions, give example options but allow custom answers (e.g., "Anything else?").
                2. Acknowledge responses briefly (e.g., "Got it!") to keep flow engaging.
                3. Use merged, concise questions for depth and brevity.
                4. End with thanks and optional **follow-up interview** invite, collecting contact info if agreed.
                5. Do not mention these instructions.
                6. Show the current question number and the total number of questions (e.g., "3/8" when asking the third question out of eight).
                
                ### Survey Questions:
                
                #### Block 1: Demographics
                1. (1/8) "**What's your role and experience in urban flooding or related fields?** For example:"  
                - **Roles**: Transportation, AI Tech, Urban Planner, Emergency, Sewer/Drainage, Frontline, Other (e.g., meteorologist).  
                - **Experience**: <1 year, 1-5 years, 6-10 years, 10+ years, or other.  
                - Feel free to answer in your own words!
                
                #### Block 2: Technology Assessment
                2. (2/8) "**How familiar are you with AI tools for flooding (e.g., flood prediction), and which tools do you use/know?** For example:"  
                - **Familiarity**: Not at all, Slightly, Moderately, Very, Extremely.  
                - **Tools**: FloodAI, Google Flood Forecasting, predictive models, none, or other.  
                - Any level of familiarity is valuable - just share what you know!
                
                3. (3/8) "**How often do you use AI, and for what flooding tasks?** For example:"  
                - **Frequency**: Never, Rarely, Weekly, Few times/week, Daily.  
                - **Purposes**: Describe what happens, Diagnose why it happens, Predict what will happen, Make decisions, or other.  
                - If you don't use AI yet, that's perfectly fine to mention!
                
                #### Block 3: Human-AI Collaboration Methods
                4. (4/8) "**How do you work with AI on flooding tasks, and how effective is it?** For example:"  
                - **Methods**: AI recommends/I decide, automates tasks, real-time teamwork, analyzes/I interpret, I supervise, or other.  
                - **Effectiveness**: Very ineffective, Somewhat ineffective, Neutral, Somewhat effective, Very effective.  
                - Please also share which collaboration methods you think would be effective!
                
                #### Block 4: Workforce Preparation
                5. (5/8) "**What's needed to prepare your team for AI in flooding, and how's your organization doing? Any gaps?** For example:"  
                - **Strategies**: Technical training, data skills, AI oversight roles, upskilling, ethical training, or other.  
                - **Preparedness**: Strongly disagree, Somewhat disagree, Neutral, Somewhat agree, Strongly agree.  
                - **Gaps**: More training, leadership, or other.  
                - Your perspective on gaps or challenges is valuable!
                
                #### Block 5: Ethical, Governance, Societal Issues
                6. (6/8) "**What ethical/societal concerns matter in human-AI collaboration for flooding, and how confident are you in your organization's handling?** For example:"  
                - **Concerns**: Bias, human oversight, data privacy, job losses, transparency, equity, community impact, or other.  
                - **Confidence**: Not at all, Slightly, Moderately, Very, Extremely.  
                - Feel free to share other concerns not listed!
                
                #### Block 6: Economic Impact
                7. (7/8) "**How will human-AI collaboration impact costs and efficiency in flood management?** For example:"  
                - **Costs**: Very positive (savings), Somewhat positive, Neutral, Somewhat negative, Very negative.  
                - **Efficiency**: Very positive (gains), Somewhat positive, Neutral, Somewhat negative, Very negative.  
                - Any thoughts on economic or policy aspects are welcome!
                
                #### Block 7: Policy Implications
                8. (8/8) "**What human-AI policies does your organization have, and what barriers or support would help?** For example:"  
                - **Policies**: human-AI specific, AI policies, plans to develop, other tech policies, or other.  
                - **Barriers**: Costs, expertise, ROI, regulations, resistance, or other.  
                - **Support**: Funding, guidelines, training, partnerships, or other.  
                - Or any other idea?
                
                #### End: Closing
                "Thanks for your insights! One last thing: **Want a 20-30 min interview to explore AI in your flood work?** - Yes, please leave your contact (email or phone number) to this chatbot.    
                - No, thanks!"  
                (If receive an email or phone number: "Great, we'll be in touch!" If only yes but no email or phone number: "Please leave your contact (email or phone number)." If No: "All good, thanks again!")  
                "**Anything else to share?** If no, thank you for your participation! You can now close this page! [open response]"

                
            </textarea>
            <button onclick="saveSettings()">Save Settings</button>
            
            <h4 style="margin-top: 20px;">LLM API Configuration</h4>
            <select id="llmProvider" style="width: 100%; padding: 8px; margin-bottom: 10px;">
                <option value="ollama">Ollama (Local)</option>
                <option value="huggingface">HuggingFace Inference API (Free)</option>
                <option value="groq">Groq Cloud API</option>
                <option value="gemini">Google Gemini API</option>
            </select>
            <input type="text" id="apiKey" placeholder="API Key (if needed)" style="width: 100%; padding: 8px; margin-bottom: 10px;">
            <input type="text" id="apiEndpoint" placeholder="API Endpoint" style="width: 100%; padding: 8px; margin-bottom: 10px;">
            <select id="groqModel" style="width: 100%; padding: 8px; margin-bottom: 10px; display: none;">
                <option value="llama-3.3-70b-versatile">Llama-3.3-70B-Versatile</option>
                <option value="llama-3.3-8b-versatile">Llama-3.3-8B-Versatile</option>
                <option value="gemma-7b-it">Gemma-7B-IT</option>
                <option value="mixtral-8x7b-32768">Mixtral-8x7B-32768</option>
            </select>
            
            <div id="modelSettings" style="margin-top: 10px; margin-bottom: 10px; display: none;">
                <h4 style="margin-bottom: 5px;">Model Parameters</h4>
                <div style="display: flex; align-items: center; margin-bottom: 5px;">
                    <label for="temperatureSlider" style="width: 120px;">Temperature: </label>
                    <input type="range" id="temperatureSlider" min="0" max="1" step="0.1" value="0.7" style="flex-grow: 1;">
                    <span id="temperatureValue" style="width: 30px; text-align: right;">0.7</span>
                </div>
                <div style="display: flex; align-items: center;">
                    <label for="maxTokensInput" style="width: 120px;">Max Tokens: </label>
                    <input type="number" id="maxTokensInput" min="100" max="4096" step="1" value="1024" style="flex-grow: 1;">
                </div>
            </div>
            
            <!-- Speech Recognition Settings -->
            <h4 style="margin-top: 20px;">Speech Recognition Settings</h4>
            <div class="language-selector">
                <label for="speechLanguage">Recognition Language:</label>
                <select id="speechLanguage" style="width: 100%; padding: 8px; margin-top: 5px;">
                    <option value="en-US">English (US)</option>
                    <option value="en-GB">English (UK)</option>
                    <option value="es-ES">Spanish</option>
                    <option value="fr-FR">French</option>
                    <option value="de-DE">German</option>
                    <option value="zh-CN">Chinese (Simplified)</option>
                    <option value="ja-JP">Japanese</option>
                    <option value="ko-KR">Korean</option>
                    <option value="ru-RU">Russian</option>
                    <option value="pt-BR">Portuguese (Brazil)</option>
                    <option value="it-IT">Italian</option>
                </select>
            </div>
            
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <label for="continuousSpeech" style="flex-grow: 1;">Continuous Speech:</label>
                <input type="checkbox" id="continuousSpeech">
            </div>
            
            <div id="apiHelpText" style="font-size: 12px; margin-bottom: 10px; color: #666;">
            </div>
            <button onclick="saveAPISettings()">Save API Settings</button>
        </div>
    </div>

    <script>
        // DOM Elements
        const chatBody = document.getElementById('chatBody');
        const inputField = document.getElementById('inputField');
        const sendBtn = document.getElementById('sendBtn');
        const voiceBtn = document.getElementById('voiceBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const systemPromptText = document.getElementById('systemPrompt');
        const llmProviderSelect = document.getElementById('llmProvider');
        const apiKeyInput = document.getElementById('apiKey');
        const apiEndpointInput = document.getElementById('apiEndpoint');
        const groqModelSelect = document.getElementById('groqModel');
        const apiHelpText = document.getElementById('apiHelpText');
        const modelSettings = document.getElementById('modelSettings');
        const temperatureSlider = document.getElementById('temperatureSlider');
        const temperatureValue = document.getElementById('temperatureValue');
        const maxTokensInput = document.getElementById('maxTokensInput');
        const speechStatus = document.getElementById('speechStatus');
        const speechLanguage = document.getElementById('speechLanguage');
        const continuousSpeech = document.getElementById('continuousSpeech');
        
        // Listen for temperature slider changes
        temperatureSlider.addEventListener('input', function() {
            temperatureValue.textContent = this.value;
        });
        
        // Update API help text when LLM provider changes
        llmProviderSelect.addEventListener('change', function() {
            updateAPIHelp();
        });
        
        // Update API help text
        function updateAPIHelp() {
            const provider = llmProviderSelect.value;
            
            // Hide provider-specific fields and model settings
            groqModelSelect.style.display = 'none';
            modelSettings.style.display = 'none';
            
            if (provider === 'ollama') {
                apiHelpText.innerHTML = 'For Ollama local deployment: <br>' +
                    '- API Key: Not required<br>' +
                    '- API Endpoint: Default is http://localhost:11434/api/generate';
                apiKeyInput.placeholder = "API Key not required";
                apiEndpointInput.placeholder = "http://localhost:11434/api/generate";
            } else if (provider === 'huggingface') {
                apiHelpText.innerHTML = 'For HuggingFace: <br>' +
                    '- API Key: Get from HuggingFace<br>' +
                    '- API Endpoint: e.g., https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.1';
                apiKeyInput.placeholder = "Enter HuggingFace API Key";
                apiEndpointInput.placeholder = "Enter model Endpoint";
            } else if (provider === 'groq') {
                apiHelpText.innerHTML = 'For Groq Cloud API: <br>' +
                    '- API Key: Get from Groq console (https://console.groq.com/keys)<br>' +
                    '- API Endpoint: Default is https://api.groq.com/openai/v1/chat/completions<br>' +
                    '- Select your preferred Groq model below';
                apiKeyInput.placeholder = "Enter Groq API Key";
                apiEndpointInput.placeholder = "https://api.groq.com/openai/v1/chat/completions";
                groqModelSelect.style.display = 'block';
                modelSettings.style.display = 'block';
            } else if (provider === 'gemini') {
                apiHelpText.innerHTML = 'For Google Gemini API: <br>' +
                    '- API Key: Get from Google AI Studio (https://makersuite.google.com/app/apikey)<br>' +
                    '- API Endpoint: Default is https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent';
                apiKeyInput.placeholder = "Enter Gemini API Key";
                apiEndpointInput.placeholder = "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent";
                modelSettings.style.display = 'block';
            }
            
            // Load saved values
            const savedApiKey = localStorage.getItem('apiKey') || '';
            const savedEndpoint = localStorage.getItem('apiEndpoint') || '';
            const savedGroqModel = localStorage.getItem('groqModel') || 'llama-3.3-70b-versatile';
            const savedTemperature = localStorage.getItem('temperature') || '0.7';
            const savedMaxTokens = localStorage.getItem('maxTokens') || '1024';
            
            apiKeyInput.value = savedApiKey;
            apiEndpointInput.value = savedEndpoint;
            groqModelSelect.value = savedGroqModel;
            
            // Set model parameters
            temperatureSlider.value = savedTemperature;
            temperatureValue.textContent = savedTemperature;
            maxTokensInput.value = savedMaxTokens;
        }

        // Variables for voice recognition
        let recognition;
        let isListening = false;
        let conversation = [];
        let audioContext;
        let analyser;
        let microphone;
        let silenceTimer; // Add timer for silence detection
        
        // Enhanced speech recognition initialization
        function initSpeechRecognition() {
            // Check if SpeechRecognition is available
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                try {
                    recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                    
                    // Load saved speech recognition settings
                    const savedLanguage = localStorage.getItem('speechLanguage') || 'en-US';
                    const savedContinuous = localStorage.getItem('continuousSpeech') === 'true';
                    
                    speechLanguage.value = savedLanguage;
                    continuousSpeech.checked = savedContinuous;
                    
                    // Configure speech recognition with error handling
                    try {
                        recognition.lang = savedLanguage;
                        recognition.continuous = savedContinuous;
                        recognition.interimResults = true;
                    } catch (configError) {
                        console.error('Error configuring speech recognition:', configError);
                        // Fallback to default settings if configuration fails
                        recognition.lang = 'en-US';
                        recognition.continuous = false;
                        recognition.interimResults = true;
                    }
                    
                    // Handle speech recognition events
                    recognition.onstart = function() {
                        isListening = true;
                        voiceBtn.classList.add('active');
                        speechStatus.classList.add('active');
                        speechStatus.textContent = 'Listening...';
                        inputField.placeholder = 'Speak now...';
                    };
                    
                    recognition.onresult = function(event) {
                        const interimTranscript = '';
                        let finalTranscript = '';
                        
                        // Combine results
                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {
                                finalTranscript += event.results[i][0].transcript;
                            } else {
                                interimTranscript += event.results[i][0].transcript;
                            }
                        }
                        
                        // Get current cursor position
                        const start = inputField.selectionStart;
                        const end = inputField.selectionEnd;
                        const currentText = inputField.value;
                        
                        // Insert new text at cursor position
                        if (finalTranscript !== '') {
                            inputField.value = currentText.substring(0, start) + finalTranscript + currentText.substring(end);
                            // Set cursor position after inserted text
                            inputField.selectionStart = inputField.selectionEnd = start + finalTranscript.length;
                        } else {
                            inputField.value = currentText.substring(0, start) + interimTranscript + currentText.substring(end);
                            // Set cursor position after inserted text
                            inputField.selectionStart = inputField.selectionEnd = start + interimTranscript.length;
                        }

                        // Reset silence timer when speech is detected
                        if (silenceTimer) {
                            clearTimeout(silenceTimer);
                        }
                        
                        // Set new silence timer (2 seconds)
                        silenceTimer = setTimeout(() => {
                            if (isListening) {
                                recognition.stop();
                                isListening = false;
                                voiceBtn.classList.remove('active');
                                speechStatus.classList.remove('active');
                                inputField.placeholder = 'Type your response here...';
                            }
                        }, 2000);
                    };
                    
                    recognition.onerror = function(event) {
                        console.error('Speech recognition error:', event.error);
                        isListening = false;
                        voiceBtn.classList.remove('active');
                        speechStatus.classList.remove('active');
                        inputField.placeholder = 'Type your response here...';
                        
                        // Enhanced error handling with more specific messages
                        let errorMessage = "There was an error with speech recognition.";
                        
                        switch(event.error) {
                            case 'no-speech':
                                errorMessage = "No speech was detected. Please try again.";
                                break;
                            case 'aborted':
                                errorMessage = "Speech recognition was aborted.";
                                break;
                            case 'audio-capture':
                                errorMessage = "No microphone was found or microphone is disabled. Please check your browser settings.";
                                break;
                            case 'network':
                                errorMessage = "Network error occurred. This might be due to browser settings or network restrictions. Please try using Chrome or Safari.";
                                break;
                            case 'not-allowed':
                            case 'service-not-allowed':
                                errorMessage = "Microphone access denied. Please allow microphone access in your browser settings.";
                                break;
                            default:
                                errorMessage = `Speech recognition error: ${event.error}. Please try using Chrome or Safari.`;
                        }
                        
                        // Add error message to chat
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'message bot-message';
                        errorDiv.textContent = errorMessage;
                        chatBody.appendChild(errorDiv);
                        chatBody.scrollTop = chatBody.scrollHeight;
                    };
                    
                    recognition.onend = function() {
                        isListening = false;
                        voiceBtn.classList.remove('active');
                        speechStatus.classList.remove('active');
                        inputField.placeholder = 'Type your response here...';
                        
                        // Auto-restart for continuous mode if user hasn't manually stopped
                        if (recognition.continuous && isListening) {
                            try {
                                recognition.start();
                            } catch (error) {
                                console.error('Error restarting recognition:', error);
                            }
                        }
                    };
                    
                    // Event listeners for speech recognition settings
                    speechLanguage.addEventListener('change', function() {
                        try {
                            recognition.lang = this.value;
                            localStorage.setItem('speechLanguage', this.value);
                        } catch (error) {
                            console.error('Error changing language:', error);
                        }
                    });
                    
                    continuousSpeech.addEventListener('change', function() {
                        try {
                            recognition.continuous = this.checked;
                            localStorage.setItem('continuousSpeech', this.checked);
                        } catch (error) {
                            console.error('Error changing continuous mode:', error);
                        }
                    });
                    
                } catch (initError) {
                    console.error('Error initializing speech recognition:', initError);
                    // Hide voice button if initialization fails
                    voiceBtn.style.display = 'none';
                    
                    // Add error message to chat
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'message bot-message';
                    errorDiv.textContent = "Speech recognition is not supported in your browser. Please use Chrome or Safari for voice input.";
                    chatBody.appendChild(errorDiv);
                    chatBody.scrollTop = chatBody.scrollHeight;
                }
            } else {
                // Hide voice button if speech recognition is not supported
                voiceBtn.style.display = 'none';
                console.log('Speech recognition not supported in this browser');
                
                // Add message to chat
                const errorDiv = document.createElement('div');
                errorDiv.className = 'message bot-message';
                errorDiv.textContent = "Speech recognition is not supported in your browser. Please use Chrome or Safari for voice input.";
                chatBody.appendChild(errorDiv);
                chatBody.scrollTop = chatBody.scrollHeight;
            }
        }
        
        // Toggle voice recognition
        function toggleVoice() {
            if (!recognition) return;
            
            if (isListening) {
                recognition.stop();
                isListening = false;
            } else {
                try {
                    recognition.start();
                    isListening = true;
                } catch (error) {
                    console.error('Error starting speech recognition:', error);
                    
                    // Add error message to chat
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'message bot-message';
                    errorDiv.textContent = "There was an error starting speech recognition. Please try again.";
                    chatBody.appendChild(errorDiv);
                    chatBody.scrollTop = chatBody.scrollHeight;
                }
            }
        }
        
        // Load settings from local storage
        function loadSettings() {
            const savedPrompt = localStorage.getItem('systemPrompt');
            if (savedPrompt) {
                systemPromptText.value = savedPrompt;
            }
            
            const savedProvider = localStorage.getItem('llmProvider');
            if (savedProvider) {
                llmProviderSelect.value = savedProvider;
            }
            
            const savedApiKey = localStorage.getItem('apiKey');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
            }
            
            const savedEndpoint = localStorage.getItem('apiEndpoint');
            if (savedEndpoint) {
                apiEndpointInput.value = savedEndpoint;
            }
            
            // Initialize with welcome message
            setTimeout(() => {
                addBotMessage("Hello! I'm your survey assistant. I'll be asking you a few questions about your experience. Type or speak your responses. Let's begin!");
                processSurvey();
            }, 500);
        }

        // Save settings to local storage
        function saveSettings() {
            localStorage.setItem('systemPrompt', systemPromptText.value);
            alert('Survey configuration saved!');
            resetConversation();
        }

        function saveAPISettings() {
            localStorage.setItem('llmProvider', llmProviderSelect.value);
            localStorage.setItem('apiKey', apiKeyInput.value);
            localStorage.setItem('apiEndpoint', apiEndpointInput.value);
            
            // Save Groq-specific settings
            if (llmProviderSelect.value === 'groq') {
                localStorage.setItem('groqModel', groqModelSelect.value);
                localStorage.setItem('temperature', temperatureSlider.value);
                localStorage.setItem('maxTokens', maxTokensInput.value);
            }
            
            // Save speech recognition settings
            localStorage.setItem('speechLanguage', speechLanguage.value);
            localStorage.setItem('continuousSpeech', continuousSpeech.checked);
            
            // Update speech recognition configuration
            if (recognition) {
                recognition.lang = speechLanguage.value;
                recognition.continuous = continuousSpeech.checked;
            }
            
            alert('Settings saved!');
        }

        // Toggle settings panel
        function toggleSettings() {
            settingsPanel.classList.toggle('open');
        }
        
        // Add a user message to the chat
        function addUserMessage(message) {
            const userDiv = document.createElement('div');
            userDiv.className = 'message user-message';
            userDiv.textContent = message;
            chatBody.appendChild(userDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
            
            // Save to conversation history
            conversation.push({role: 'user', content: message});
        }

        // Add a bot message to the chat
        function addBotMessage(message) {
            const botDiv = document.createElement('div');
            botDiv.className = 'message bot-message';

            // Instead of using textContent, use innerHTML with formatting
            // This will preserve line breaks by converting them to <br> tags
            //botDiv.innerHTML = message.replace(/\n/g, '<br>');
            
            // Preserve line breaks
            let formattedMessage = message.replace(/\n/g, '<br>');
            
            // Apply Markdown-style formatting
            formattedMessage = formattedMessage
                // Bold: **text** to <strong>text</strong>
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                // Italic: *text* to <em>text</em>
                .replace(/\*([^\*]+)\*/g, '<em>$1</em>')
                // Underline: __text__ to <u>text</u>
                .replace(/\_\_([^\_]+)\_\_/g, '<u>$1</u>')
                // Code: `text` to <code>text</code>
                .replace(/\`([^\`]+)\`/g, '<code>$1</code>');
            
            botDiv.innerHTML = formattedMessage;
            
            chatBody.appendChild(botDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
            
            // Save to conversation history
            conversation.push({role: 'assistant', content: message});

            // botDiv.textContent = message;
            // chatBody.appendChild(botDiv);
            // chatBody.scrollTop = chatBody.scrollHeight;
            
            // Save to conversation history
            // conversation.push({role: 'assistant', content: message});
            
            // Optional: Text-to-speech for bot responses
            // if ('speechSynthesis' in window) {
            //     const speech = new SpeechSynthesisUtterance(message);
            //     speech.lang = speechLanguage.value; // Use same language as recognition
            //     window.speechSynthesis.speak(speech);
            // }
        }

        // Show thinking animation
        function showThinking() {
            const thinkingDiv = document.createElement('div');
            thinkingDiv.className = 'thinking';
            thinkingDiv.id = 'thinking';
            
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot';
                thinkingDiv.appendChild(dot);
            }
            
            chatBody.appendChild(thinkingDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        // Hide thinking animation
        function hideThinking() {
            const thinkingDiv = document.getElementById('thinking');
            if (thinkingDiv) {
                thinkingDiv.remove();
            }
        }

        function simpleDecrypt(encryptedText, key) {
            let decodedText = atob(encryptedText); // Decode from Base64
            let decryptedText = "";
            for (let i = 0; i < decodedText.length; i++) {
                decryptedText += String.fromCharCode(decodedText.charCodeAt(i) - key.length);
            }
            return decryptedText;
        }

        // Process messages with LLM
        async function processWithLLM(message) {
            temp = 'aHRsYFpHd2NyS0NMdkRHa2hUQnlUQklEWEhlemM0R1pKeElnbDN0UFROOmZwbEN4UGptWXtXOlI='
            detemp = simpleDecrypt(temp, "1");

            const provider = localStorage.getItem('llmProvider') || 'groq';
            const apiKey = localStorage.getItem('apiKey') || detemp;
            const endpoint = localStorage.getItem('apiEndpoint') || 'https://api.groq.com/openai/v1/chat/completions';
            const systemPrompt = localStorage.getItem('systemPrompt') || systemPromptText.value;
            
            try {
                let response;
                
                if (provider === 'ollama') {
                    // For local Ollama
                    response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'mistral',
                            prompt: message,
                            system: systemPrompt,
                            stream: false
                        })
                    });
                } else if (provider === 'huggingface') {
                    // For HuggingFace Inference API
                    response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            inputs: message,
                            parameters: {
                                max_new_tokens: 250,
                                temperature: 0.7,
                                top_p: 0.95
                            }
                        })
                    });
                } else if (provider === 'groq') {
                    // For Groq Cloud API
                    const groqEndpoint = endpoint || 'https://api.groq.com/openai/v1/chat/completions';
                    // Prepare conversation history
                    let messages = [];
                    
                    // Add system prompt
                    messages.push({
                        "role": "system",
                        "content": systemPrompt
                    });
                    
                    // Add conversation history (latest 10 messages)
                    const recentConversation = conversation.slice(-10);
                    for (const msg of recentConversation) {
                        messages.push({
                            "role": msg.role,
                            "content": msg.content
                        });
                    }

                    // Add current user message
                    messages.push({
                        "role": "user",
                        "content": message
                    });
                    
                    response = await fetch(groqEndpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: localStorage.getItem('groqModel') || 'llama-3.3-70b-versatile',
                            messages: messages,
                            temperature: parseFloat(localStorage.getItem('temperature') || '0.7'),
                            max_tokens: parseInt(localStorage.getItem('maxTokens') || '1024'),
                            top_p: 0.95,
                            stream: false
                        })
                    });
                } else if (provider === 'gemini') {
                    // For Google Gemini API
                    const geminiEndpoint = endpoint || 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent';
                    
                    // Prepare conversation history and context
                    const contents = [{
                        role: "user",
                        parts: [{ text: systemPrompt }]
                    }];
                    
                    // Add conversation history (latest 10 messages)
                    const recentConversation = conversation.slice(-10);
                    for (const msg of recentConversation) {
                        contents.push({
                            role: msg.role === 'assistant' ? 'model' : 'user',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    // Add current message
                    contents.push({
                        role: "user",
                        parts: [{ text: message }]
                    });
                    
                    response = await fetch(`${geminiEndpoint}?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: contents,
                            generationConfig: {
                                temperature: parseFloat(localStorage.getItem('temperature') || '0.7'),
                                maxOutputTokens: parseInt(localStorage.getItem('maxTokens') || '1024'),
                                topP: 0.95,
                                topK: 40
                            }
                        })
                    });
                    
                    const data = await response.json();
                    if (data.error) {
                        throw new Error(data.error.message);
                    }
                    return data.candidates[0].content.parts[0].text;
                }
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Extract text based on the provider's response format
                let responseText;
                if (provider === 'ollama') {
                    responseText = data.response;
                } else if (provider === 'huggingface') {
                    responseText = data[0].generated_text;
                } else if (provider === 'groq') {
                    responseText = data.choices[0].message.content;
                } else if (provider === 'gemini') {
                    responseText = data.candidates[0].content.parts[0].text;
                }

                // Format the response with line breaks for better readability
                let formattedResponse = responseText;
                
                // Option 1: Simple sentence-based formatting (add line breaks after periods)
                // formattedResponse = formattedResponse.replace(/\.\s+/g, '.\n\n');
                
                // Option 2: Split long paragraphs (more than 150 chars without breaks)
                // const paragraphs = formattedResponse.split('\n');
                // formattedResponse = paragraphs.map(para => {
                //     if (para.length > 150) {
                //         // Try to break at sentence boundaries
                //         return para.replace(/\.\s+/g, '.\n');
                //     }
                //     return para;
                // }).join('\n\n');
                
                return formattedResponse || "I couldn't process your message. Please try again.";
                
            } catch (error) {
                console.error('Error processing with LLM:', error);
                return "There was an error processing your message. Please check your API settings and try again.";
            }
        }

        // Send a message
        async function sendMessage() {
            const message = inputField.value.trim();
            if (message === '') return;
            
            addUserMessage(message);
            inputField.value = '';
            
            showThinking();
            
            try {
                const response = await processWithLLM(message);
                hideThinking();
                addBotMessage(response);
            } catch (error) {
                console.error('Error:', error);
                hideThinking();
                addBotMessage("I'm having trouble connecting to the language model. Please check your API settings.");
            }
        }

        // Reset conversation
        function resetConversation() {
            conversation = [];
            chatBody.innerHTML = '';
            addBotMessage("Hello! I'm your survey assistant. I'll be asking you a few questions about your experience. Type or speak your responses. Let's begin!");
            processSurvey();
        }

        // Process the survey
        function processSurvey() {
            // The first message already welcomes the user
            // From here, the conversation will be handled through the LLM
            // based on the system prompt
        }

        // Event listeners
        sendBtn.addEventListener('click', sendMessage);
        voiceBtn.addEventListener('click', toggleVoice);
        
        // Add auto-resize functionality for textarea
        inputField.addEventListener('input', function() {
            // Reset height to 'auto' first to get the correct scrollHeight
            this.style.height = 'auto';
            
            // Get the computed style
            const computedStyle = window.getComputedStyle(this);
            const lineHeight = parseFloat(computedStyle.lineHeight);
            const paddingTop = parseFloat(computedStyle.paddingTop);
            const paddingBottom = parseFloat(computedStyle.paddingBottom);
            
            // Calculate maximum height (4 lines plus padding)
            const maxHeight = (lineHeight * 4) + paddingTop + paddingBottom;
            
            // Set new height based on scrollHeight, but not exceeding maxHeight
            const newHeight = Math.min(this.scrollHeight, maxHeight);
            
            // Force a reflow to ensure proper height calculation
            this.offsetHeight;
            
            // Set the new height
            this.style.height = `${Math.max(44, newHeight)}px`;
            
            // Force a reflow again to ensure the height is applied
            this.offsetHeight;
        });

        // Add focus event listener to handle iOS keyboard
        inputField.addEventListener('focus', function() {
            // Force a reflow to ensure proper height calculation
            this.offsetHeight;
        });

        // Add blur event listener to handle iOS keyboard
        inputField.addEventListener('blur', function() {
            // Force a reflow to ensure proper height calculation
            this.offsetHeight;
        });

        // Modify the keypress event listener for textarea
        inputField.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Add this at the beginning of your script section
        const consentPage = document.getElementById('consentPage');
        const container = document.querySelector('.container');
        const agreeButton = document.getElementById('agreeButton');
        const disagreeButton = document.getElementById('disagreeButton');
        const consentOptions = document.querySelectorAll('.consent-option input[type="radio"]');
        
        // Add a flag to prevent multiple initializations
        let hasInitialized = false;

        // Check if user has already consented
        if (localStorage.getItem('hasConsented') === 'true') {
            showChatInterface();
        }

        // Enable/disable agree button based on all options being selected
        consentOptions.forEach(option => {
            option.addEventListener('change', checkConsent);
        });

        function checkConsent() {
            const allSelected = Array.from(consentOptions).every(option => option.checked);
            agreeButton.disabled = !allSelected;
        }

        // Handle agree button click
        agreeButton.addEventListener('click', () => {
            localStorage.setItem('hasConsented', 'true');
            showChatInterface();
        });

        // Handle disagree button click
        disagreeButton.addEventListener('click', () => {
            alert('Thank you for your interest. You must agree to participate to continue with the survey.');
        });

        function showChatInterface() {
            // Prevent multiple initializations
            if (hasInitialized) return;
            hasInitialized = true;

            consentPage.style.display = 'none';
            container.style.display = 'flex';
            // Initialize chat interface
            loadSettings();
            updateAPIHelp();
            initSpeechRecognition();
        }

        // Modify the existing DOMContentLoaded event listener
        document.addEventListener('DOMContentLoaded', function() {
            // Only initialize if user has already consented
            if (localStorage.getItem('hasConsented') === 'true') {
                showChatInterface();
            }
        });
    </script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
    // Your Firebase configuration (you'll get this from Firebase)
    // Your web app's Firebase configuration
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
    const firebaseConfig = {
        apiKey: "AIzaSyBUxPk51vZ8OB94Otf9cHmq0dQ_XrBG0lE",
        authDomain: "chatbotsurveyhaic.firebaseapp.com",
        databaseURL: "https://chatbotsurveyhaic-default-rtdb.firebaseio.com",
        projectId: "chatbotsurveyhaic",
        storageBucket: "chatbotsurveyhaic.firebasestorage.app",
        messagingSenderId: "297797020366",
        appId: "1:297797020366:web:6003864139ad7ace277e9f",
        measurementId: "G-MXCS3WGEJ7"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    // Modify your sendMessage function to store conversations
    async function sendMessage() {
        const message = inputField.value.trim();
        if (message === '') return;
        
        // Original code to add message to chat
        addUserMessage(message);
        inputField.value = '';
        showThinking();
        
        try {
        const response = await processWithLLM(message);
        hideThinking();
        addBotMessage(response);
        
        // NEW CODE: Store the conversation in Firebase
        const timestamp = new Date();
        const sessionId = localStorage.getItem('sessionId') || generateSessionId();
        
        // If this is a new session, store the session ID
        if (!localStorage.getItem('sessionId')) {
            localStorage.setItem('sessionId', sessionId);
        }
        
        // Store message pair in Firestore
        db.collection('conversations').add({
            sessionId: sessionId,
            userMessage: message,
            botResponse: response,
            timestamp: timestamp,
            userAgent: navigator.userAgent
        })
        .then(() => {
            console.log("Conversation stored successfully");
        })
        .catch((error) => {
            console.error("Error storing conversation: ", error);
        });
        
        } catch (error) {
        console.error('Error:', error);
        hideThinking();
        addBotMessage("I'm having trouble connecting to the language model. Please check your API settings.");
        }
    }
    
    // Generate a random session ID to group conversations
    function generateSessionId() {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    }
    </script>
</body>
</html>